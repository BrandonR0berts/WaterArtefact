#version 430 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D positionOutput;
layout(rgba32f, binding = 1) uniform image2D normalOutput;
layout(rgba32f, binding = 2) uniform image2D tangentOutput;
layout(rgba32f, binding = 3) uniform image2D binormalOutput;

uniform float time;
uniform int waveCount;

// --------------------------------------------------------

struct SineWaveData
{
	float amplitude;
	float steepnessFactor;
	float waveLength;
	float speedOfWave;

	float directionOfWaveX;
	float directionOfWaveZ;
	float padding1;
	float padding2;
};

layout (std430, binding = 5) readonly buffer WaveData
{
	SineWaveData waves[];
};

// --------------------------------------------------------

float CalculateHeight(ivec2 texelCoord)
{
	float finalHeight = 0.0;

	for(int i = 0; i < waveCount; i++)
	{
		vec2 direction = vec2(1.0, 1.0);

		if(waves[i].directionOfWaveX > 0.0 || waves[i].directionOfWaveZ > 0.0)
			direction = normalize(vec2(waves[i].directionOfWaveX, waves[i].directionOfWaveZ));
	
		float frequency     = 2.0 / waves[i].waveLength;
		float phaseConstant = waves[i].speedOfWave * frequency;

		finalHeight += waves[i].amplitude * sin((dot(direction, texelCoord) * frequency) + (time * phaseConstant));
	}
	
	return finalHeight;
}

// --------------------------------------------------------

float CalculateXDeritive(ivec2 texelCoord)
{
	return 0.0;
}

// --------------------------------------------------------

float CalculateYDeritive(ivec2 texelCoord)
{
	return 0.0;
}

// --------------------------------------------------------

//https://developer.nvidia.com/gpugems/gpugems/part-i-natural-effects/chapter-1-effective-water-simulation-physical-models

void main()
{
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	// Position
	vec4 finalValue  = vec4(0.0, CalculateHeight(texelCoord), 0.0, 1.0);
    imageStore(positionOutput, texelCoord, finalValue);

	finalValue.y = 0.0;

	// Binormal
	float xDeritive = CalculateXDeritive(texelCoord);

	finalValue.x = 1.0;
	finalValue.y = 0.0;
	finalValue.y = xDeritive;

	imageStore(binormalOutput, texelCoord, finalValue);

	// Tangent
	float yDeritive = CalculateYDeritive(texelCoord);

	finalValue.x = 0.0;
	finalValue.y = 1.0;
	finalValue.y = yDeritive;

	imageStore(tangentOutput, texelCoord, finalValue);	

	// Normal
	finalValue.x = -xDeritive;
	finalValue.y = -yDeritive;
	finalValue.z = 1.0;
	imageStore(normalOutput, texelCoord, finalValue);
}

// --------------------------------------------------------