#version 430 core

// This shader is to convert from fourier domain into world space domain

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// --------------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform readonly  image2D fourierDomainInput;    // Input complex data
layout(rgba32f, binding = 1) uniform writeonly image2D worldPositionOutput;   // Output data 

// --------------------------------------------------------------------------------

// Useful functionality
struct ComplexNumber
{
	float real;
	float complex;
};

ComplexNumber DivideComplex(ComplexNumber num1, float factor)
{
	return ComplexNumber(num1.real / factor, num1.complex / factor);
}

ComplexNumber MultiplyComplex(ComplexNumber num1, float factor)
{
	return ComplexNumber(num1.real * factor, num1.complex * factor);
}

ComplexNumber MultiplyComplex(ComplexNumber num1, ComplexNumber num2)
{
	return ComplexNumber((num1.real * num2.real)    - (num1.complex * num2.complex), 
	                     (num1.real * num2.complex) + (num1.complex * num2.real));
}

ComplexNumber AddComplexNumber(ComplexNumber num1, ComplexNumber num2)
{
	return ComplexNumber(num1.real + num2.real, num1.complex + num2.complex);
}

ComplexNumber ComplexCast(vec2 inputs)
{
	return ComplexNumber(inputs.x, inputs.y);
}

const float PI = 3.141529;

// --------------------------------------------------------------------------------

vec2 CreateK(float n, float m, float resolution)
{
	return vec2((2.0 * PI * n) / resolution,
	            (2.0 * PI * m) / resolution);
}

// --------------------------------------------------------------------------------

void main()
{
	// ----------------------------------------------------------------------------------

	// Get the current pixel we are processing
	ivec2 pixelCoord      = ivec2(gl_GlobalInvocationID.xy);

	// Image resoultion - X and Y dimensions should be the same and a power of 2
	ivec2 resolution      = imageSize(fourierDomainInput);
	float floatResolution = float(resolution.x);
	vec2  texelCoord      = vec2(pixelCoord) / floatResolution;

	// ----------------------------------------------------------------------------------

	ComplexNumber result;
	result.real    = 0.0;
	result.complex = 0.0;

	vec2 xVector = vec2((texelCoord.x - 0.5) * floatResolution, 
					    (texelCoord.y - 0.5) * floatResolution);

	// Go through every pixel on the screen, perform the FFT equation to it and sum them
	for(int z = 0; z < resolution.y; z++)
	{
		for(int x = 0; x < resolution.x; x++)
		{
			// h~(k, t) * exp(ik dot x)
			// where h~(k, t) is the value read from the pixel
			// and k = (2 * pi * n / lx, 2 * pi * m / lz)
			// And -N/2 < n < N/2
			// and -M/2 < m < M/2
			// x = (x, z)

			// exp(ik dot x) = cos(k dot x) + isin(k dot x)

			// Calculate k
			float n = ((float(z) / floatResolution) - 0.5) * floatResolution;
			float m = ((float(x) / floatResolution) - 0.5) * floatResolution;

			vec2 k = CreateK(n, m, floatResolution);

			float kDotX = dot(xVector, k);

			ComplexNumber multiplier;
			multiplier.real    = cos(kDotX);
			multiplier.complex = sin(kDotX);

			// Read this pixel's data
			vec2 hTilde = imageLoad(fourierDomainInput, ivec2(x, z)).xy;

			// Add on the portion for this pixel
			result = AddComplexNumber(result, MultiplyComplex(ComplexCast(hTilde), multiplier));
		}
	}

	imageStore(worldPositionOutput, pixelCoord, vec4(result.real, result.complex, 0.0, 0.0));

	// ----------------------------------------------------------------------------------
}

// --------------------------------------------------------------------------------