#version 430 core

// The resolution of the image is the N in these equations. N determines the amount of waves that are generated.

// This shader is for calculating the current frequency values in the fourier domain.
// The output of this shader will go into the inverse FFT shader for the final height values


layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// --------------------------------------------------------------------------------

layout(rgba32f, binding = 0) uniform writeonly image2D positionOutput;
layout(rgba32f, binding = 1) uniform writeonly image2D normalOutput;
layout(rgba32f, binding = 2) uniform writeonly image2D tangentOutput;
layout(rgba32f, binding = 3) uniform writeonly image2D binormalOutput;

layout(rgba32f, binding = 4) uniform readonly image2D h0Input;

// --------------------------------------------------------------------------------

uniform float time;

uniform float repeatAfterTime;
uniform float gravity;

// --------------------------------------------------------------------------------

const float PI                      = 3.141529;
const float dispersionRelation_zero = (2.0 * PI) / repeatAfterTime;

// --------------------------------------------------------------------------------

struct ComplexNumber
{
	float real;
	float complex;
};

ComplexNumber AddComplex(ComplexNumber num1, ComplexNumber num2)
{
	return ComplexNumber(num1.real + num2.real, num1.complex + num2.complex);
}

ComplexNumber MultiplyComplex(ComplexNumber num1, ComplexNumber num2)
{
	return ComplexNumber((num1.real * num2.real)    - (num1.complex * num2.complex), 
	                     (num1.real * num2.complex) + (num1.complex * num2.real));
}

ComplexNumber Conjugate(ComplexNumber num)
{
	return ComplexNumber(num.real, -num.complex);
}

ComplexNumber ComplexCast(vec2 inputValues)
{
	return ComplexNumber(inputValues.x, inputValues.y);
}

// --------------------------------------------------------------------------------

vec2 CreateK(float n, float m, float resolution)
{
	return vec2(2.0 * PI * n / resolution,
	            2.0 * PI * m / resolution);
}

// --------------------------------------------------------------------------------

// w(k) = [[w(k)/w0]] * w0
float CreateDispersion(vec2 k)
{
	float magnitudeOfK = k.length();
	float w            = sqrt(magnitudeOfK * gravity);

	return floor(w / dispersionRelation_zero) * dispersionRelation_zero;
}

// --------------------------------------------------------------------------------

void main()
{
	vec4 finalValue = vec4(0.0, 0.0, 0.0, 1.0);

	// 0 -> 1 position for the point on the texture
	ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

	// Convert the texelcoord into mesh space, (+- half mesh dimensions)
	ivec2 resolution = imageSize(positionOutput);

	//vec2  texelCoord           = vec2(pixelCoord) / resolution;
	ivec2 transposedTexelCoord = ivec2(resolution.x - pixelCoord.x, resolution.y - pixelCoord.y);

	// Determine the n and m positions in mesh space, 
	// These are the 'x' and 'z' relative positions
	// These need to be calculated to make the centre of the output image essentially 0,0
	float n = (pixelCoord.x - 0.5) * resolution.x;
	float m = (pixelCoord.y - 0.5) * resolution.y;

	// Wave vector 'k'
	vec2 k = CreateK(n, m, float(resolution));

	// Dispersion relation factor
	float dispersionRelation = CreateDispersion(k);
	
	// Grab the H0 values we are going to be using
	ComplexNumber h0Normal    = ComplexCast(imageLoad(h0Input, pixelCoord).xy);
	ComplexNumber h0Transpose = ComplexCast(imageLoad(h0Input, transposedTexelCoord).xy); 

	// Convert the exponential equations into sine and cosine using euler's equation
	// e^^ix = cos(x) + isin(x)
	ComplexNumber firstHalfFactor  = ComplexNumber(cos(dispersionRelation * time), sin(       dispersionRelation * time));
	ComplexNumber secondHalfFactor = ComplexNumber(cos(dispersionRelation * time), sin(-1.0 * dispersionRelation * time));

	// Calculate the final fourier domain value
	// H0(k)e^^iw(k)t + h0transpose(-k)e^^-iw(k)t
	ComplexNumber outputComplexNumber = AddComplex(MultiplyComplex(h0Normal, firstHalfFactor), MultiplyComplex(Conjugate(h0Transpose), secondHalfFactor));

	// ---------------------------------------------------------- //

	finalValue.x = outputComplexNumber.real;
	finalValue.y = outputComplexNumber.complex;	

	// Output the final fourier domain value to the texture
    imageStore(positionOutput, pixelCoord, finalValue);
}

// --------------------------------------------------------------------------------